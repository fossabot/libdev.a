{
  "name": "Libdev.a",
  "tagline": "A small helpers library for C language",
  "body": "<p align=\"center\">\r\n<img src=\".pic.png\" /><br />\r\n<img src=\"https://img.shields.io/badge/language-C-blue.svg\"/> &nbsp;\r\n<img src=\"https://img.shields.io/badge/license-Apache--2.0-yellow.svg\" /> &nbsp;\r\n<img src=\"https://travis-ci.com/Ne02ptzero/libdev.a.svg?token=Ljxx7MA94JpJdnRDQunq&branch=master\" />\r\n</p>\r\n\r\n-----------------------------------------------------------------\r\n\r\n<p align=\"center\">A small developer library with some helpers in it</p>\r\n<p align=\"center\">                                                              \r\n  <a href=\"#linked-lists\">Linked Lists</a> • <a href=\"#type-definitions\">Types Definitions</a> • <a href=\"#singletons\">Singletons</a> • <a href=\"#print-helpers\">Print Helpers</a> • <a href=\"#assertions\">Assertions</a> • <a href=\"#unit-tests\">Unit Tests</a>\r\n</p>\r\n\r\n\r\n\r\n## Usage & Installation\r\n### Clone the repository\r\n```\r\ngit clone https://github.com/Ne02ptzero/libdev.a\r\n```\r\n### Compile\r\n```\r\nmake\r\n```\r\n### Use\r\nYou'll need to include the header file in your project's code\r\n```C\r\n#include <libdev.h>\r\n```\r\nCompilation\r\n```\r\ngcc myfile.c -L library_directory -ldev\r\n```\r\n<h2 align=\"center\">HELPERS</h2>\r\n## Linked Lists\r\nIn libdev, all the linked lists are from the same struct\r\n```C\r\ntypedef struct\t\ts_list {\r\n\tvoid\t\t\t\t*member;\t// Actual member\r\n\tsize_t\t\t\t\tsize; \t\t// Size of the member\r\n\tstruct s_list\t\t*next;\t\t// Next in list\r\n\tstruct s_list\t\t*prev;\t\t// Prev in list\r\n\tstruct s_list\t\t*head;\t\t// Head of the list\r\n}\t\t\t\t\tt_list;\r\n\r\n```\r\nIn all my examples, I will use the following struct as an example. But you're free to use any type of data you want to. ```void *``` Magic !\r\n```C\r\ntypedef struct    s_example {\r\n  int         a;\r\n  char        b;\r\n}                 t_example;\r\n```\r\nHere's how to use it:\r\n### Add a member\r\n#### Define\r\n```C\r\nlist_add(t_list *main_list, void *new_member, size_t size_of_the_new_member); // MACRO\r\n\r\n```\r\n#### Example\r\n```C\r\nt_example\t\tmember;\r\nt_list\t\t\t*list = NULL; // Important, on the first creation the list pointer _needs_ to be NULL.\r\n\r\nmember.a = 3;\r\nmember.b = 'l';\r\nlist_add(list, &member, sizeof(t_example));\r\n```\r\nThis code will add the ```t_example member``` to a new linked list.\r\nNote there is no list initialization, you just need to set the pointer to NULL the first time you create it.\r\nIf the list already exist, the member will be added at the end.\r\n### Iteration over a list\r\n#### Define\r\n```C\r\nlist_for_each(t_list *list_head, t_list *tmp, void *member); // MACRO\r\n```\r\n#### Example\r\nOur new struct as already been added in the list, now we want to iterate over it:\r\n```C\r\nt_list\t\t*tmp;\r\nt_example\t*ptr;\r\n\r\nlist_for_each(list, tmp, ptr) {\r\n\tprintf(\"%d - %c\\n\", ptr->a, ptr->b);\r\n}\r\n```\r\n```list``` is the head of the list pointer, ```tmp``` is just a ```t_list``` pointer (used to iterate without changing the head pointer), and ```ptr``` is your custom pointer. In this example, it's a ```t_example *```, but you can do it with anything.\r\n### Reverse Iteration\r\n#### Define\r\n```C\r\nlist_for_each_rev(t_list *list_head, t_list *tmp, void *member); // MACRO\r\n```\r\n#### Example\r\nWorking the same way as ```list_for_each```, but instead of beginning at the list head, and follow the members by ```next```, it's beginning from the tail and follow the members by ```prev```\r\n### Add After\r\n#### Define\r\n```C\r\nlist_add_after(t_list *list_head, t_list *list_entry, void *member, size_t size_of_the_member); // MACRO\r\n```\r\n#### Example\r\nWorking the same way as ```list_add```, but instead of adding the new member at the end, it's adding the new member after the ```list_entry``` member.\r\n### Add Before\r\n#### Define\r\n```C\r\nlist_add_before(t_list *list_head, t_list *list_entry, void *member, size_t size_of_the_member); // MACRO\r\n```\r\n#### Example\r\nWorking the same way as ```list_add```, but instead of adding the new member at the end, it's adding the new member before the ```list_entry``` member.\r\n### Useful functions\r\n```C\r\nsize_t\t\tlist_size(t_list *list); // Function\r\n```\r\nGet the list size.\r\n```C\r\nlist_tail(t_list *head_list); // MACRO\r\n```\r\nReturn the last ```t_list *``` entry in ```head_list```.\r\n```C\r\nvoid\t*list_get(t_list *list_head, void *ptr, size_t size);\r\n```\r\nSearch into the ```list_head``` linked list, compare each ```member``` to ```ptr``` with ```memcmp```. Return the ```member``` if found, ```NULL``` if not. ```size``` is for memory comparation.\r\n## Type definitions\r\nTypes helpers in order to achieve easy bits / data manipulation\r\n\r\nReal Type | Name | Size (bits) | Size (Bytes) | Range\r\n--------- | ---- | ----------- | ------------ | -----\r\nsigned char | s8_t | 8 | 1 | -128 to 127\r\nunsigned char | u8_t | 8 | 1 | 0 to 255\r\nsigned short | s16_t | 16 | 2 | -32,768 to 32,767\r\nunsigned short | u16_t | 16 | 2 | 0 to 65,535\r\nsigned int | s32_t | 32 | 4 | -2,147,483,648 to 2,147,483,647\r\nunsigned int | u32_t | 32 | 4 | 0 to 4,294,967,295\r\nsigned long long | s64_t | 64 | 8 | -9,223,372,036,854,775,807 to 9,223,372,036,854,775,807\r\nunsigned long long | u64_t | 64 | 8 | 0 to 18,446,744,073,709,551,615\r\n\r\n## Singletons\r\n#### Definition\r\n```C\r\nvoid\t\t*singleton_lists(u8_t list_type, void *ptr);\r\n```\r\n#### Example\r\nSingletons are a way to avoid global variables. The way it works is quite simple: You set a variable to a function, this function stores it, and you can retrieve the same variable later. Let's see an example:\r\n```C\r\nenum {\r\n  T_LISTS\r\n};\r\n\r\n// ...\r\n\r\nt_list\t\t*list;\r\n// We do some things with this list\r\nsingleton_lists(T_LISTS, list);\r\n\r\n// Some function, far far away ...\r\n\r\nlist = singleton_lists(T_LISTS, NULL);\r\n```\r\nIn order to set / retrieve the list, you need an unique identifier. In this example, an enum is used, but you can actually use what you want. Some notes though: The id used needs to be unique, and in a range of a ```unsigned char```.\r\n\r\nNote: In this example, i use a ```t_list``` pointer, but you can pass any data you want to store. ```void *``` Magic !\r\n## Print Helpers\r\n### Info\r\n#### Definition\r\n```C\r\nvoid\t\tinfo(char *str, ...);\r\n```\r\nPrint an information\r\n#### Example\r\n```C\r\ninfo(\"This information is very important: %s\\n\", \"No, not really\");\r\n```\r\n### Warning\r\n#### Definition\r\n```C\r\nvoid\t\twarning(char *str, ...);\r\n```\r\nPrint a warning (stderr output)\r\n#### Example\r\n```C\r\nwarning(\"Something bad happened ! Code: %d\\n\", 10);\r\n```\r\n### Error\r\n#### Definition\r\n```C\r\nvoid\t\terror(char *str, ...);\r\n```\r\nPrint an error (stderr output), print a backtrace then quit with code 1\r\n#### Example\r\n```C\r\nerror(\"We need to stop for this reason: %s\\n\", \"UNACCEPTABLE CONDITIOOOOONS\");\r\n```\r\n\r\nAs you can see in the examples above, all the print functions use the printf format.\r\n\r\n## Assertions\r\nAn assertion is a simple test on a condition. If the condition is false, the program stop.\r\n#### Definition\r\n```C\r\nL_ASSERT(condition); // MACRO\r\n```\r\n#### Example\r\n```C\r\nchar\t*str;\r\n\r\nstr = malloc(10);\r\n// Test the malloc\r\nL_ASSERT(str);\r\n```\r\nIf the malloc failed, this is what the print look like:\r\n```\r\n> Assertion (str) failed at main.c:29\r\n> Function: function5\r\n> Backtrace:\r\n> ./a.out(print_trace+0x19) [0x400cac]\r\n> ./a.out(function5+0x6b) [0x400c81]\r\n> ./a.out(function4+0xe) [0x400c14]\r\n> ./a.out(function3+0xe) [0x400c04]\r\n> ./a.out(function2+0xe) [0x400bf4]\r\n> ./a.out(function1+0xe) [0x400be4]\r\n> ./a.out(main+0x9) [0x400c8c]\r\n> /lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xf5) [0x7f2694011b45]\r\n> ./a.out() [0x400b09]\r\n```\r\nNote that if you want the function names in your backtrace, you _must_ compile your code with the ```-rdynamic``` flag.\r\n\r\n## Unit Tests\r\n### Declare a test\r\n#### Definition\r\n```C\r\nTEST(name); // MACRO\r\n```\r\n#### Example\r\n```C\r\nTEST(test_name) {\r\n\t...\r\n}\r\n```\r\n#### Do the test\r\nInside the test, you must use the ```T_ASSERT``` macro. Here's a simple example\r\n```C\r\nTEST(test_name) {\r\n\tint\ti = 1;\r\n\tT_ASSERT(i == 1, \"Bad initialization\");\r\n\treturn TEST_SUCCESS;\r\n}\r\n```\r\nIn this example, we are testing than ```i``` is equal to 1. In order to do that, we call ```T_ASSERT```. Same as ```L_ASSERT```, this macro return an error if the condition is wrong. But rather than quitting the program, it just return the error to the test handler. Here's an example output if the test failed:\r\n```\r\n> Testing test_name ...                            [ FAILED ]\r\n> \tBad initialization: Test: 'i == 1', File main.c:33\r\n```\r\nAs you see, the second parameter of the macro is the error returned if the test failed.\r\nThe error message max length is 250.\r\n\r\nYou *must* finish all of your tests with the ```TEST_SUCCESS``` macro, in order to inform the test handler that all went well.\r\n\r\n### Register a Test\r\nYour test is now declared, but you must register it to the test handler. In libdev.a, all the tests are registered in groups.\r\n#### Definition\r\n```C\r\nreg_test(group, name); // MACRO\r\n```\r\n#### Example\r\nIf you want to register the ```test_name``` test, you must write this.\r\n```C\r\nreg_test(\"Test Group\", test_name);\r\n```\r\nGroups are for ... grouped tests.\r\n### Launch a Group Test\r\nNow that all our tests are registered, time to launch them !\r\n#### Definition\r\n```C\r\nt_test_results\ttest_group(char *group); // FUNCTION\r\n```\r\n#### Example\r\nHere's how to launch:\r\n```C\r\ntest_group(\"Test Group\");\r\n```\r\nThis function will run all the tests registered under the name ```Test Group```, in order of insertion.\r\nAs you can see, this function return a structure. Here's the content:\r\n```C\r\ntypedef struct\t\ts_test_results {\r\n\tsize_t\t\t\t\tsuccess;\r\n\tsize_t\t\t\t\tfailed;\r\n\tsize_t\t\t\t\ttotal;\r\n}\t\t\t\t\tt_test_results;\r\n```\r\nJust a quick result of the tests. You can completly ignore it if you want to.\r\n\r\nExample output:\r\n```\r\n================================== linked_list ===================================\r\n> Testing list_add_null ...                                                 [ OK ]\r\n> Testing list_add_member ...                                               [ OK ]\r\n> Testing list_add_member_head_list ...                                     [ OK ]\r\n> Testing list_add_member_test_multiples ...                                [ FAILED ]\r\n> \tHead pointer is not right: Test: '!(ptr->next->head == ptr)', File main.c:48\r\n> Testing list_for_each ...                                                 [ OK ]\r\n> Testing list_tail ...                                                     [ OK ]\r\n> Testing list_add_after ...                                                [ OK ]\r\n> Testing list_add_before ...                                               [ OK ]\r\n> Testing list_for_each_rev ...                                             [ OK ]\r\n> Testing list_size ...                                                     [ OK ]\r\n> Results: Total: 10, Success: 9, Failed: 1. COVERAGE: 90%\r\n```\r\n\r\n### Launch all the Tests\r\n#### Defintion\r\n```C\r\nvoid\t\t\ttest_all(void); // FUNCTION\r\n```\r\n#### Example\r\nThe usage is pretty straightforward:\r\n```\r\ntest_all();\r\n```\r\nThis will launch all the group test, one by one, then print a result.\r\n\r\nExample output:\r\n```\r\n================================== linked_list ===================================\r\n> Testing list_add_null ...                                                 [ OK ]\r\n> Testing list_add_member ...                                               [ OK ]\r\n> Testing list_add_member_head_list ...                                     [ OK ]\r\n> Testing list_add_member_test_multiples ...                                [ FAILED ]\r\n> \tHead pointer is not right: Test: '!(ptr->next->head == ptr)', File main.c:48\r\n> Testing list_for_each ...                                                 [ OK ]\r\n> Testing list_tail ...                                                     [ OK ]\r\n> Testing list_add_after ...                                                [ OK ]\r\n> Testing list_add_before ...                                               [ OK ]\r\n> Testing list_for_each_rev ...                                             [ OK ]\r\n> Testing list_size ...                                                     [ OK ]\r\n> Results: Total: 10, Success: 9, Failed: 1. COVERAGE: 90%\r\n===================================== types ======================================\r\n> Testing s8_t ...                                                          [ OK ]\r\n> Testing u8_t ...                                                          [ OK ]\r\n> Testing s16_t ...                                                         [ OK ]\r\n> Testing u16_t ...                                                         [ OK ]\r\n> Testing s32_t ...                                                         [ OK ]\r\n> Testing u32_t ...                                                         [ OK ]\r\n> Testing s64_t ...                                                         [ OK ]\r\n> Testing u64_t ...                                                         [ OK ]\r\n> Results: Total: 8, Success: 8, Failed: 0. COVERAGE: 100%\r\n=================================== singletons ===================================\r\n> Testing singleton_set ...                                                 [ OK ]\r\n> Testing singleton_get ...                                                 [ OK ]\r\n> Testing singleton_replace ...                                             [ OK ]\r\n> Results: Total: 3, Success: 3, Failed: 0. COVERAGE: 100%\r\n\r\n==================================== RESULTS =====================================\r\n> TESTS SUCCESS:\t20\r\n> TESTS FAILED:\t\t1\r\n> TOTAL COVERAGE:\t95%\r\n```",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}